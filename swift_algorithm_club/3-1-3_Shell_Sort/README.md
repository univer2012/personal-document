# 希尔排序(Shell Sort)

来自：
1. [希尔排序(Shell Sort)](https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Shell%20Sort)

 2. [Shell Sort](https://github.com/andyRon/swift-algorithm-club/tree/master/Shell%20Sort)

---

## 例子

假设我们想使用希尔排序对数组 `[64, 20, 50, 33, 72, 10, 23, -1, 4]` 进行排序。

我们首先将数组的长度除以2：

    n = floor(9/2) = 4

这是 *gap* 大小。

我们创建`n`子列表。 在每个子列表中，每一项的间隔是大小为`n`的*gap* 。 在我们的示例中，我们需要制作其中四个子列表。 子列表按`insertionSort()`函数排序。

这可能没有多大意义，所以让我们仔细看看会发生什么。

第一轮如下。 我们有`n = 4`，所以我们制作了四个子列表：

	sublist 0:  [ 64, xx, xx, xx, 72, xx, xx, xx, 4  ]
	sublist 1:  [ xx, 20, xx, xx, xx, 10, xx, xx, xx ]
	sublist 2:  [ xx, xx, 50, xx, xx, xx, 23, xx, xx ]
	sublist 3:  [ xx, xx, xx, 33, xx, xx, xx, -1, xx ]

如您所见，每个子列表仅包含原始数组中的每间隔4的项。 不在子列表中的项用`xx`表示。 所以第一个子列表是`[64,72,4]`，第二个子列表是`[20,10]`，依此类推。 我们使用这个“*gap*”的原因是我们不必实际制作新的数组。 相反，我们将它们交织在原始数组中。

我们现在在每个子列表上调用一次`insertionSort()`。

[插入排序](../Insertion%20Sort/)的这个特定版本从后面到前面排序。子列表中的每个项目都与其他项目进行比较。如果它们的顺序错误，则交换值并一直向下移动，直到我们到达子列表的开头。

因此对于子列表0，我们将`4`与`72`交换，然后将`4`与`64`交换。 排序后，此子列表如下所示：

    sublist 0:  [ 4, xx, xx, xx, 64, xx, xx, xx, 72 ]

排序后的其他三个子列表：

	sublist 1:  [ xx, 10, xx, xx, xx, 20, xx, xx, xx ]
	sublist 2:  [ xx, xx, 23, xx, xx, xx, 50, xx, xx ]
	sublist 3:  [ xx, xx, xx, -1, xx, xx, xx, 33, xx ]

完整的数组看上去是：

	[ 4, 10, 23, -1, 64, 20, 50, 33, 72 ]

它还没有完全排序，但它比以前更加排序。 这完成了第一次轮操作。

在第二轮中，我们将 *gap* 大小除以2：

	n = floor(4/2) = 2

这意味着我们现在只创建两个子列表：

	sublist 0:  [  4, xx, 23, xx, 64, xx, 50, xx, 72 ]
	sublist 1:  [ xx, 10, xx, -1, xx, 20, xx, 33, xx ]

每个子列表包含每个间隔为2的项。 我们再次调用`insertionSort()`来对这些子列表进行排序。 结果是：

	sublist 0:  [  4, xx, 23, xx, 50, xx, 64, xx, 72 ]
	sublist 1:  [ xx, -1, xx, 10, xx, 20, xx, 33, xx ]

请注意，在每个列表中只有两个元素位置顺序不对（译注：**sublist 0**是64和50，**sublist 1**是10和-1）。 因此插入排序非常快。 那是因为我们已经在第一轮中对数组进行了一些排序。

总数组现在看起来像这样：

	[ 4, -1, 23, 10, 50, 20, 64, 33, 72 ]

这样就完成了第二轮。 最后一轮的*gap*是：

	n = floor(2/2) = 1

 *gap* 大小为1表示我们只有一个子列表，即数组本身，我们再次调用`insertionSort()`对其进行排序。 最终排序的数组是：
```
	[ -1, 4, 10, 20, 23, 33, 50, 64, 72 ]
```

在大多数情况下，希尔排序的性能为**O(n^2)**，如果幸运，则为 **O(nlogn)**。 该算法是**不稳定的排序**; 它可能会改变具有相等值的元素的相对顺序。
